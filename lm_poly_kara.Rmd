---
title: 'Linear Model: Polystyrene Analysis'
author: "Kara McCormack"
output:
  pdf_document: default
  html_notebook: default
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(echo=TRUE, include=TRUE)
```

## Load Libraries
```{r}
library(readr)
library(phyloseq)
library(ggplot2)
library(dplyr)
library(stringr)
library(tidyr)
library(magrittr)
library(vegan)
```

## Goals: 
1. Subset by location
2. Subset by condition
3. Conduct a linear regression with the following variables:
  * x = Week
  * y = OTU relative abundance
4. Order by $R^2$ values, want to use those with high $R^2$ value
5. Order by coefficient value on week, want to use those with higher coefficient
  * this mean that time is significant for relative abundance for that OTU
  * this means that that OTU might be a polystyrene degrader
  

## Define Paths
```{r}
poly.rds ="/sharedspace/polystyrene/demultiplexed5/dada2/ibiemProject1_subset.rds"
```

## Check Phyloseq RDS
Load your phyloseq RDS and `print` it just to be sure things look sane
```{r}
poly.ps = read_rds(poly.rds)
print(poly.ps)
```

## Rename Week variable
```{r}
# calculate relative abundance
rel <-transform_sample_counts(poly.ps, function(OTU) OTU/sum(OTU))

# turn the otu table into a data.frame
otu <- as.data.frame(otu_table(rel))
head(otu)

# grab first and last OTU's names for referencing columns in pivot_longer
first_otu <- colnames(otu)[1]
last_otu <- colnames(otu)[ncol(otu)]

otu %>%
  pivot_longer(first_otu:last_otu, 
               names_to = "OTU", 
               values_to = "Relative Abundance") %>%
  head
```

## Subset samples
```{r}
ps_LF <- subset_samples(poly.ps, Location=="LF")
ps_ER <- subset_samples(poly.ps, Location=="ER")
ps_AS <- subset_samples(poly.ps, Location=="AS")
ps_RC <- subset_samples(poly.ps, Location=="RC")
```

## Calculate relative abundance
```{r}
rel_ps_LF <-transform_sample_counts(ps_LF, function(OTU) OTU/sum(OTU))
rel_ps_ER <-transform_sample_counts(ps_ER, function(OTU) OTU/sum(OTU))
rel_ps_AS <-transform_sample_counts(ps_AS, function(OTU) OTU/sum(OTU))
rel_ps_RC <-transform_sample_counts(ps_RC, function(OTU) OTU/sum(OTU))
```


## Subset by Condition
We break apart the Landfill phyloseq object into four categories:

* Control
* Polystyrene
* Styrene
* Polystyrene + Styrene

```{r}
LF_ctrl <- subset_samples(rel_ps_LF, Condition == "Ctrl")
LF_ps <- subset_samples(rel_ps_LF, Condition == "PS")
LF_s <- subset_samples(rel_ps_LF, Condition == "S")
LF_pss <- subset_samples(rel_ps_LF, Condition == "PSS")
```

### Begin threshold_function items

## Subset to those with nonzero values for week 7 and 12
We will filter out those with less than 0.1% relative abundance at weeks 7 and 12, because we want to look at those that have some substantial presence at those weeks, in order to even consider them as polystyrene degraders.
```{r}
# Grab OTUs from each condition and make into data frame
LF_df_ctrl <- as.data.frame(otu_table(LF_ctrl))
LF_df_ps <- as.data.frame(otu_table(LF_ps))
LF_df_s <- as.data.frame(otu_table(LF_s))
LF_df_pss <- as.data.frame(otu_table(LF_pss))

```

```{r}
# reorder data frame so that weeks are in correct order
LF_df_ctrl <- LF_df_ctrl[c(1, 3:8, 2),]
LF_df_ps <- LF_df_ps[c(1, 3:8, 2),]
LF_df_s <- LF_df_s[c(1, 3:8, 2),]
LF_df_pss <- LF_df_pss[c(1, 3:8, 2),]
```

```{r}
# add week as a column
Week <- c(1:7, 12)

# Landfill 
LF_df_ctrl <- LF_df_ctrl %>%
  mutate(Week = as.factor(Week)) %>%
  select(Week, everything())
```

```{r}
# subset into only those OTUs with greater than 0.1% at weeks 7 and 12
subset <- LF_df_ctrl %>%
  pivot_longer(-Week,
               names_to = "OTU", 
               values_to = "Relative Abundance") %>%
  filter(Week == 7 | Week == 12) %>% 
  filter(`Relative Abundance` > .001) 

dim(subset)
head(subset)

otu_names <- unique(subset$OTU)
length(otu_names)
```
So we have 383 total samples in the Landfill site where, in the control condition, the OTUs had greater than .1% abundance at both weeks 7 and 12. Since some of these exceeded the threshold at both weeks 7 and 12, we see that there are a total of 220 unique OTUs satisfying this requirement. 

Now, we need to perform linear regression on only those OTUs. 

First, we will subset the OTU table using only those OTUs satisfying the threshold requirement. 
```{r}
LF_df_ctrl_subset <- LF_df_ctrl[,colnames(LF_df_ctrl)%in%otu_names]
dim(LF_df_ctrl_subset)
```
Now, we will loop through these OTUs, performing linear regression on each relative abundance as a function of Week. 

```{r}
options(scipen = 999)
week <- c(1:7, 12)
result <- NULL
for(otu in 2:ncol(LF_df_ctrl_subset)){
  my_col <- as.vector(LF_df_ctrl_subset[,otu])
  result[otu] <- round(summary(lm(my_col ~ week))$r.squared, digits = 3)
}
result[order(result, decreasing = T)]
```
Now we list OTUs that had an R-squared above 0.5. 
```{r}
# count the number of OTUs with R-squared values above 0.5
num_above <- sum(result[order(result, decreasing = T)] >.5, na.rm = T)

# grab the indices of the OTUs with R-squared values above 0.5
ord <- order(result, decreasing = T)[1:num_above]

# subset the dataframe with only those OTUs. 
result_LF_ctrl <- LF_df_ctrl_subset[ , ord]
result_LF_ctrl[,1:2]
```


## Function to find those above relative abundance threshold
```{r}
# input: data frame of otu_table at specific site with specific condition
#     - Note: columns are in the correct order in terms of weeks!
# output: dataframe of OTUs satisfying requirement for relative abundance threshold, how many satisfy the threshold
Week <- c(1:7, 12)

# get rid of scientific notation
options(scipen = 999)

threshold_func <- function(df, threshold = .5){

subset <- df %>%
  # add week as a column
  mutate(Week = as.factor(Week)) %>% 
  
  # move week to the beginning of the data frame
  select(Week, everything()) %>% 
  
  # convert to long format 
  pivot_longer(-Week, 
               
               # change sequence column name to "OTU"
               names_to = "OTU", 
               
               # change relative abundance column name to "Relative Abundance"
               values_to = "Relative Abundance") %>%
  
  # for weeks 7 and 12
  filter(Week == 7 | Week == 12) %>% 
  
  # subset into only those OTUs with greater than 0.1% at weeks 7 and 12
  filter(`Relative Abundance` > .001)

# grab OTU names that met this requirement
otu_names <- unique(subset$OTU)

# how many OTUs satisfied the requriement?
print(paste0("There are ", length(otu_names), " OTUs with > 0.1% at weeks 7 and 12."))

# subset the full dataframe by only these OTUs
df_subset <- df[ , colnames(df) %in% otu_names]

# instantiate empty vector
result <- NULL
slope <- NULL

for(otu in 2:ncol(df_subset)){
  
  # grab the specific OTU column as a vector
  my_col <- as.vector(df_subset[ , otu])
  
  # calculate r.squared value from linear regression, put value in "result"
  result[otu] <- round(summary(lm(my_col ~ Week))$r.squared, digits = 3)
  slope[otu] <- round(summary(lm(my_col ~ Week))$coefficients[2, 1], digits = 3)
}

# count the number of OTUs with R-squared values above threshold (default 0.5)
num_above <- sum(result[order(result, decreasing = T)] > threshold, na.rm = T)

# how many OTUs satisfied the requriement?
print(paste0(num_above, " of those OTUs have r.squared value > " , threshold))

# grab the indices of the OTUs with R-squared values above 0.5
ord <- order(result, decreasing = T)[1:num_above]

# subset the dataframe with only those OTUs. 
df_subset_r.squared <- df_subset[ , ord]

return(list(otu_names_7_12 = otu_names,
            r.squared.result.full = result[order(result, decreasing = T)],
            df_subset_r.squared = df_subset_r.squared,
            otu_names_7_12_r.squared = colnames(df_subset_r.squared)))
}
```

```{r}
# small example
x <- 1:10
x
y <- 2*x + rnorm(10, 0, 3)

fit <- lm(y ~ x)
summary(fit)$coefficients
summary(fit)$coefficients[2,1]
```

## Landfill Results
```{r}
# try function on Landfill site, control condition
result_ctrl <- threshold_func(LF_df_ctrl, threshold = 0.5)
```
```{r}
# use function on Landfill site, PS condition
result_ps <- threshold_func(LF_df_ps, threshold = 0.5)
```

```{r}
# use function on Landfill site, S condition
result_s <- threshold_func(LF_df_s, threshold = 0.5)
```

```{r}
# use function on Landfill site, PSS condition
result_pss <- threshold_func(LF_df_s, threshold = 0.5)
```

Now, we want to see if any of the OTUs passed both sets of requirements for all four conditions. 
```{r}
result_pss[[4]]
unique(c(result_ctrl[[4]],
       result_ps[[4]],
       result_s[[4]],
       result_pss[[4]]))

result_ctrl[[4]][result_ctrl[[4]] %in% result_ps[[4]]] %in% result_s[[4]]

```

So, none of the OTUs passed both sets of requirements for all four conditions.

## AS Results
We break apart the Elizabeth River (ER) phyloseq object into four categories:

* Control
* Polystyrene
* Styrene
* Polystyrene + Styrene

```{r}
ER_ctrl <- subset_samples(rel_ps_ER, Condition == "Ctrl")
ER_ps <- subset_samples(rel_ps_ER, Condition == "PS")
ER_s <- subset_samples(rel_ps_ER, Condition == "S")
ER_pss <- subset_samples(rel_ps_ER, Condition == "PSS")
```

```{r}
# Grab OTUs from each condition and make into data frame
ER_df_ctrl <- as.data.frame(otu_table(ER_ctrl))
ER_df_ps <- as.data.frame(otu_table(ER_ps))
ER_df_s <- as.data.frame(otu_table(ER_s))
ER_df_pss <- as.data.frame(otu_table(ER_pss))

```

```{r}
# reorder data frame so that weeks are in correct order
ER_df_ctrl <- ER_df_ctrl[c(1, 3:8, 2),]
ER_df_ps <- ER_df_ps[c(1, 3:8, 2),]
ER_df_s <- ER_df_s[c(1, 3:8, 2),]
ER_df_pss <- ER_df_pss[c(1, 3:8, 2),]
```

## Elizabeth River Results
```{r}
# try function on Landfill site, control condition
result_ER_ctrl <- threshold_func(ER_df_ctrl, threshold = 0.5)
```
```{r}
# use function on Landfill site, PS condition
result_ER_ps <- threshold_func(ER_df_ps, threshold = 0.5)
```

```{r}
# use function on Landfill site, S condition
result_ER_s <- threshold_func(ER_df_s, threshold = 0.5)
```

```{r}
# use function on Landfill site, PSS condition
result_ER_pss <- threshold_func(ER_df_pss, threshold = 0.5)
```


```{r}
result_ER_ctrl[[4]][result_ER_ctrl[[4]] %in% result_ER_ps[[4]]] %in% result_ER_s[[4]]

```

## New plan
```{r}
subset <- LF_df_ctrl %>%
  # add week as a column
  mutate(Week = as.factor(Week)) %>% 
  
  # move week to the beginning of the data frame
  select(Week, everything()) %>% 
  
  # convert to long format 
  pivot_longer(-Week, 
               
               # change sequence column name to "OTU"
               names_to = "OTU", 
               
               # change relative abundance column name to "Relative Abundance"
               values_to = "Relative Abundance") %>%
  
  # for weeks 7 and 12
  filter(Week == 7 | Week == 12) %>% 
  
  # subset into only those OTUs with greater than 0.1% at weeks 7 and 12
  filter(`Relative Abundance` > .001)

# grab OTU names that met this requirement
otu_names <- unique(subset$OTU)
```

## Landfill: LM on control
```{r}
week <- c(1:7, 12)
ctrl_result_slope <- NULL

for (otu in colnames(LF_df_ctrl)[-1]){
  response_ctrl <- LF_df_ctrl[, otu]
  ctrl_result_slope[otu] <- summary(lm(response_ctrl ~ week))$coefficients[2,1]
}
ctrl_result_slope
```

## Landfill: LM on PS
```{r}
ps_result_slope <- NULL

for (otu in colnames(LF_df_ps)){
  response_ps <- LF_df_ps[, otu]
  ps_result_slope[otu] <- summary(lm(response_ps ~ week))$coefficients[2,1]
}

```

## Landfill: LM on S
```{r}
s_result_slope <- NULL

for (otu in colnames(LF_df_s)){
  response_s <- LF_df_s[, otu]
  s_result_slope[otu] <- summary(lm(response_s ~ week))$coefficients[2,1]
}
```

## Landfill: LM on PSS
```{r}
pss_result_slope <- NULL

for (otu in colnames(LF_df_pss)){
  response_pss <- LF_df_pss[, otu]
  pss_result_slope[otu] <- summary(lm(response_pss ~ week))$coefficients[2,1]
}
```
Just look at those with bigger slope in PS, S, or PSS versus Control.

Now we can find the top five OTUs from each comparison that have a bigger slope compared with Control. 
## Compare PS with Ctrl
```{r}
compare_ps <- ps_result_slope - ctrl_result_slope
names(compare_ps)[order(compare_ps, decreasing = T)][1:5]
```

## Compare S with Ctrl
```{r}
compare_s <- s_result_slope - ctrl_result_slope
names(compare_s)[order(compare_s, decreasing = T)][1:5]
```

## Compare PSS with Ctrl
```{r}
compare_pss <- pss_result_slope - ctrl_result_slope
names(compare_pss)[order(compare_pss, decreasing = T)][1:5]
```

## ER Results
```{r}
# Grab OTUs from each condition and make into data frame
ER_df_ctrl <- as.data.frame(otu_table(ER_ctrl))
ER_df_ps <- as.data.frame(otu_table(ER_ps))
ER_df_s <- as.data.frame(otu_table(ER_s))
ER_df_pss <- as.data.frame(otu_table(ER_pss))

# reorder data frame so that weeks are in correct order
ER_df_ctrl <- ER_df_ctrl[c(1, 3:8, 2),]
ER_df_ps <- ER_df_ps[c(1, 3:8, 2),]
ER_df_s <- ER_df_s[c(1, 3:8, 2),]
ER_df_pss <- ER_df_pss[c(1, 3:8, 2),]
```

```{r}
week <- c(1:7, 12)
my_comparison <- function(control_df, compare_df, top = 5){

ctrl_result_slope <- NULL

for (otu in colnames(control_df)){
  response_ctrl <- control_df[, otu]
  ctrl_result_slope[otu] <- summary(lm(response_ctrl ~ week))$coefficients[2,1]
}

compare_result_slope <- NULL

for (otu in colnames(compare_df)){
  response_compare <- compare_df[, otu]
  compare_result_slope[otu] <- summary(lm(response_compare ~ week))$coefficients[2,1]
}

slope_diff <- compare_result_slope - ctrl_result_slope
return(names(slope_diff)[order(compare_pss, decreasing = T)][1:top])

}
```

